# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: edu/uci/ics/amber/engine/architecture/rpc/controlcommands.proto, edu/uci/ics/amber/engine/architecture/rpc/controllerservice.proto, edu/uci/ics/amber/engine/architecture/rpc/controlreturns.proto, edu/uci/ics/amber/engine/architecture/rpc/testerservice.proto, edu/uci/ics/amber/engine/architecture/rpc/workerservice.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import core as ___core__
from .. import (
    sendsemantics as _sendsemantics__,
    worker as _worker__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ChannelMarkerType(betterproto.Enum):
    """Enum for ChannelMarkerType"""

    REQUIRE_ALIGNMENT = 0
    NO_ALIGNMENT = 1


class ConsoleMessageType(betterproto.Enum):
    PRINT = 0
    ERROR = 1
    COMMAND = 2
    DEBUGGER = 3


class ErrorLanguage(betterproto.Enum):
    PYTHON = 0
    SCALA = 1


class WorkflowAggregatedState(betterproto.Enum):
    UNINITIALIZED = 0
    READY = 1
    RUNNING = 2
    PAUSING = 3
    PAUSED = 4
    RESUMING = 5
    COMPLETED = 6
    FAILED = 7
    UNKNOWN = 8
    KILLED = 9


@dataclass(eq=False, repr=False)
class ControlRequest(betterproto.Message):
    propagate_channel_marker_request: "PropagateChannelMarkerRequest" = (
        betterproto.message_field(1, group="sealed_value")
    )
    """request for controller"""

    take_global_checkpoint_request: "TakeGlobalCheckpointRequest" = (
        betterproto.message_field(2, group="sealed_value")
    )
    debug_command_request: "DebugCommandRequest" = betterproto.message_field(
        3, group="sealed_value"
    )
    evaluate_python_expression_request: "EvaluatePythonExpressionRequest" = (
        betterproto.message_field(4, group="sealed_value")
    )
    modify_logic_request: "ModifyLogicRequest" = betterproto.message_field(
        5, group="sealed_value"
    )
    retry_workflow_request: "RetryWorkflowRequest" = betterproto.message_field(
        6, group="sealed_value"
    )
    console_message_triggered_request: "ConsoleMessageTriggeredRequest" = (
        betterproto.message_field(8, group="sealed_value")
    )
    port_completed_request: "PortCompletedRequest" = betterproto.message_field(
        9, group="sealed_value"
    )
    worker_state_updated_request: "WorkerStateUpdatedRequest" = (
        betterproto.message_field(10, group="sealed_value")
    )
    link_workers_request: "LinkWorkersRequest" = betterproto.message_field(
        11, group="sealed_value"
    )
    add_input_channel_request: "AddInputChannelRequest" = betterproto.message_field(
        50, group="sealed_value"
    )
    """request for worker"""

    add_partitioning_request: "AddPartitioningRequest" = betterproto.message_field(
        51, group="sealed_value"
    )
    assign_port_request: "AssignPortRequest" = betterproto.message_field(
        52, group="sealed_value"
    )
    finalize_checkpoint_request: "FinalizeCheckpointRequest" = (
        betterproto.message_field(53, group="sealed_value")
    )
    initialize_executor_request: "InitializeExecutorRequest" = (
        betterproto.message_field(54, group="sealed_value")
    )
    update_executor_request: "UpdateExecutorRequest" = betterproto.message_field(
        55, group="sealed_value"
    )
    empty_request: "EmptyRequest" = betterproto.message_field(56, group="sealed_value")
    prepare_checkpoint_request: "PrepareCheckpointRequest" = betterproto.message_field(
        57, group="sealed_value"
    )
    query_statistics_request: "QueryStatisticsRequest" = betterproto.message_field(
        58, group="sealed_value"
    )
    ping: "Ping" = betterproto.message_field(100, group="sealed_value")
    """request for testing"""

    pong: "Pong" = betterproto.message_field(101, group="sealed_value")
    nested: "Nested" = betterproto.message_field(102, group="sealed_value")
    pass_: "Pass" = betterproto.message_field(103, group="sealed_value")
    error_command: "ErrorCommand" = betterproto.message_field(104, group="sealed_value")
    recursion: "Recursion" = betterproto.message_field(105, group="sealed_value")
    collect: "Collect" = betterproto.message_field(106, group="sealed_value")
    generate_number: "GenerateNumber" = betterproto.message_field(
        107, group="sealed_value"
    )
    multi_call: "MultiCall" = betterproto.message_field(108, group="sealed_value")
    chain: "Chain" = betterproto.message_field(109, group="sealed_value")


@dataclass(eq=False, repr=False)
class EmptyRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AsyncRpcContext(betterproto.Message):
    sender: "___core__.ActorVirtualIdentity" = betterproto.message_field(1)
    receiver: "___core__.ActorVirtualIdentity" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ControlInvocation(betterproto.Message):
    method_name: str = betterproto.string_field(1)
    command: "ControlRequest" = betterproto.message_field(2)
    context: "AsyncRpcContext" = betterproto.message_field(3)
    command_id: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class ChannelMarkerPayload(betterproto.Message):
    """Message for ChannelMarkerPayload"""

    id: "___core__.ChannelMarkerIdentity" = betterproto.message_field(1)
    marker_type: "ChannelMarkerType" = betterproto.enum_field(2)
    scope: List["___core__.ChannelIdentity"] = betterproto.message_field(3)
    command_mapping: Dict[str, "ControlInvocation"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class PropagateChannelMarkerRequest(betterproto.Message):
    source_op_to_start_prop: List["___core__.PhysicalOpIdentity"] = (
        betterproto.message_field(1)
    )
    id: "___core__.ChannelMarkerIdentity" = betterproto.message_field(2)
    marker_type: "ChannelMarkerType" = betterproto.enum_field(3)
    scope: List["___core__.PhysicalOpIdentity"] = betterproto.message_field(4)
    target_ops: List["___core__.PhysicalOpIdentity"] = betterproto.message_field(5)
    marker_command: "ControlRequest" = betterproto.message_field(6)
    marker_method_name: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class TakeGlobalCheckpointRequest(betterproto.Message):
    estimation_only: bool = betterproto.bool_field(1)
    checkpoint_id: "___core__.ChannelMarkerIdentity" = betterproto.message_field(2)
    destination: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class WorkflowReconfigureRequest(betterproto.Message):
    reconfiguration: "ModifyLogicRequest" = betterproto.message_field(1)
    reconfiguration_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DebugCommandRequest(betterproto.Message):
    worker_id: str = betterproto.string_field(1)
    cmd: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class EvaluatePythonExpressionRequest(betterproto.Message):
    expression: str = betterproto.string_field(1)
    operator_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ModifyLogicRequest(betterproto.Message):
    update_request: List["UpdateExecutorRequest"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RetryWorkflowRequest(betterproto.Message):
    workers: List["___core__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ConsoleMessage(betterproto.Message):
    worker_id: str = betterproto.string_field(1)
    timestamp: datetime = betterproto.message_field(2)
    msg_type: "ConsoleMessageType" = betterproto.enum_field(3)
    source: str = betterproto.string_field(4)
    title: str = betterproto.string_field(5)
    message: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class ConsoleMessageTriggeredRequest(betterproto.Message):
    console_message: "ConsoleMessage" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PortCompletedRequest(betterproto.Message):
    port_id: "___core__.PortIdentity" = betterproto.message_field(1)
    input: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class WorkerStateUpdatedRequest(betterproto.Message):
    state: "_worker__.WorkerState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class LinkWorkersRequest(betterproto.Message):
    link: "___core__.PhysicalLink" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Ping(betterproto.Message):
    """Ping message"""

    i: int = betterproto.int32_field(1)
    end: int = betterproto.int32_field(2)
    to: "___core__.ActorVirtualIdentity" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Pong(betterproto.Message):
    """Pong message"""

    i: int = betterproto.int32_field(1)
    end: int = betterproto.int32_field(2)
    to: "___core__.ActorVirtualIdentity" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Pass(betterproto.Message):
    """Pass message"""

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Nested(betterproto.Message):
    """Nested message"""

    k: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class MultiCall(betterproto.Message):
    """MultiCall message"""

    seq: List["___core__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ErrorCommand(betterproto.Message):
    """ErrorCommand message"""

    pass


@dataclass(eq=False, repr=False)
class Collect(betterproto.Message):
    """Collect message"""

    workers: List["___core__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GenerateNumber(betterproto.Message):
    """GenerateNumber message"""

    pass


@dataclass(eq=False, repr=False)
class Chain(betterproto.Message):
    """Chain message"""

    nexts: List["___core__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Recursion(betterproto.Message):
    """Recursion message"""

    i: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class AddInputChannelRequest(betterproto.Message):
    """Messages for the commands"""

    channel_id: "___core__.ChannelIdentity" = betterproto.message_field(1)
    port_id: "___core__.PortIdentity" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AddPartitioningRequest(betterproto.Message):
    tag: "___core__.PhysicalLink" = betterproto.message_field(1)
    partitioning: "_sendsemantics__.Partitioning" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AssignPortRequest(betterproto.Message):
    port_id: "___core__.PortIdentity" = betterproto.message_field(1)
    input: bool = betterproto.bool_field(2)
    schema: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    storage_uris: List[str] = betterproto.string_field(4)
    partitionings: List["_sendsemantics__.Partitioning"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class FinalizeCheckpointRequest(betterproto.Message):
    checkpoint_id: "___core__.ChannelMarkerIdentity" = betterproto.message_field(1)
    write_to: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class InitializeExecutorRequest(betterproto.Message):
    total_worker_count: int = betterproto.int32_field(1)
    op_exec_init_info: "___core__.OpExecInitInfo" = betterproto.message_field(2)
    is_source: bool = betterproto.bool_field(3)


@dataclass(eq=False, repr=False)
class UpdateExecutorRequest(betterproto.Message):
    target_op_id: "___core__.PhysicalOpIdentity" = betterproto.message_field(1)
    new_executor: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    state_transfer_func: "betterproto_lib_google_protobuf.Any" = (
        betterproto.message_field(3)
    )


@dataclass(eq=False, repr=False)
class PrepareCheckpointRequest(betterproto.Message):
    checkpoint_id: "___core__.ChannelMarkerIdentity" = betterproto.message_field(1)
    estimation_only: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class QueryStatisticsRequest(betterproto.Message):
    filter_by_workers: List["___core__.ActorVirtualIdentity"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ControlReturn(betterproto.Message):
    """The generic return message"""

    retrieve_workflow_state_response: "RetrieveWorkflowStateResponse" = (
        betterproto.message_field(1, group="sealed_value")
    )
    """controller responses"""

    propagate_channel_marker_response: "PropagateChannelMarkerResponse" = (
        betterproto.message_field(2, group="sealed_value")
    )
    take_global_checkpoint_response: "TakeGlobalCheckpointResponse" = (
        betterproto.message_field(3, group="sealed_value")
    )
    evaluate_python_expression_response: "EvaluatePythonExpressionResponse" = (
        betterproto.message_field(4, group="sealed_value")
    )
    start_workflow_response: "StartWorkflowResponse" = betterproto.message_field(
        5, group="sealed_value"
    )
    worker_state_response: "WorkerStateResponse" = betterproto.message_field(
        50, group="sealed_value"
    )
    """worker responses"""

    worker_metrics_response: "WorkerMetricsResponse" = betterproto.message_field(
        51, group="sealed_value"
    )
    finalize_checkpoint_response: "FinalizeCheckpointResponse" = (
        betterproto.message_field(52, group="sealed_value")
    )
    control_error: "ControlError" = betterproto.message_field(101, group="sealed_value")
    """common responses"""

    empty_return: "EmptyReturn" = betterproto.message_field(102, group="sealed_value")
    string_response: "StringResponse" = betterproto.message_field(
        103, group="sealed_value"
    )
    int_response: "IntResponse" = betterproto.message_field(104, group="sealed_value")


@dataclass(eq=False, repr=False)
class EmptyReturn(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ControlError(betterproto.Message):
    error_message: str = betterproto.string_field(1)
    error_details: str = betterproto.string_field(2)
    stack_trace: str = betterproto.string_field(3)
    language: "ErrorLanguage" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class ReturnInvocation(betterproto.Message):
    command_id: int = betterproto.int64_field(1)
    return_value: "ControlReturn" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class StringResponse(betterproto.Message):
    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class IntResponse(betterproto.Message):
    value: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class RetrieveWorkflowStateResponse(betterproto.Message):
    state: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class FinalizeCheckpointResponse(betterproto.Message):
    size: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class PropagateChannelMarkerResponse(betterproto.Message):
    returns: Dict[str, "ControlReturn"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class TakeGlobalCheckpointResponse(betterproto.Message):
    total_size: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class TypedValue(betterproto.Message):
    expression: str = betterproto.string_field(1)
    value_ref: str = betterproto.string_field(2)
    value_str: str = betterproto.string_field(3)
    value_type: str = betterproto.string_field(4)
    expandable: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class EvaluatedValue(betterproto.Message):
    value: "TypedValue" = betterproto.message_field(1)
    attributes: List["TypedValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EvaluatePythonExpressionResponse(betterproto.Message):
    values: List["EvaluatedValue"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StartWorkflowResponse(betterproto.Message):
    workflow_state: "WorkflowAggregatedState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class WorkerStateResponse(betterproto.Message):
    state: "_worker__.WorkerState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class WorkerMetricsResponse(betterproto.Message):
    metrics: "_worker__.WorkerMetrics" = betterproto.message_field(1)


class RpcTesterStub(betterproto.ServiceStub):
    async def send_ping(
        self,
        ping: "Ping",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IntResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPing",
            ping,
            IntResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_pong(
        self,
        pong: "Pong",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IntResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPong",
            pong,
            IntResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_nested(
        self,
        nested: "Nested",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendNested",
            nested,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_pass(
        self,
        pass_: "Pass",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPass",
            pass_,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_error_command(
        self,
        error_command: "ErrorCommand",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendErrorCommand",
            error_command,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_recursion(
        self,
        recursion: "Recursion",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendRecursion",
            recursion,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_collect(
        self,
        collect: "Collect",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendCollect",
            collect,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_generate_number(
        self,
        generate_number: "GenerateNumber",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "IntResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendGenerateNumber",
            generate_number,
            IntResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_multi_call(
        self,
        multi_call: "MultiCall",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendMultiCall",
            multi_call,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_chain(
        self,
        chain: "Chain",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StringResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendChain",
            chain,
            StringResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class WorkerServiceStub(betterproto.ServiceStub):
    async def add_input_channel(
        self,
        add_input_channel_request: "AddInputChannelRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddInputChannel",
            add_input_channel_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_partitioning(
        self,
        add_partitioning_request: "AddPartitioningRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddPartitioning",
            add_partitioning_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def assign_port(
        self,
        assign_port_request: "AssignPortRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AssignPort",
            assign_port_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def finalize_checkpoint(
        self,
        finalize_checkpoint_request: "FinalizeCheckpointRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FinalizeCheckpointResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FinalizeCheckpoint",
            finalize_checkpoint_request,
            FinalizeCheckpointResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def flush_network_buffer(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FlushNetworkBuffer",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def initialize_executor(
        self,
        initialize_executor_request: "InitializeExecutorRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/InitializeExecutor",
            initialize_executor_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def open_executor(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/OpenExecutor",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pause_worker(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WorkerStateResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PauseWorker",
            empty_request,
            WorkerStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def prepare_checkpoint(
        self,
        prepare_checkpoint_request: "PrepareCheckpointRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PrepareCheckpoint",
            prepare_checkpoint_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_statistics(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WorkerMetricsResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/QueryStatistics",
            empty_request,
            WorkerMetricsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def resume_worker(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WorkerStateResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ResumeWorker",
            empty_request,
            WorkerStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def retrieve_state(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetrieveState",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def retry_current_tuple(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetryCurrentTuple",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_worker(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "WorkerStateResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/StartWorker",
            empty_request,
            WorkerStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def debug_command(
        self,
        debug_command_request: "DebugCommandRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/DebugCommand",
            debug_command_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def evaluate_python_expression(
        self,
        evaluate_python_expression_request: "EvaluatePythonExpressionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EvaluatedValue":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/EvaluatePythonExpression",
            evaluate_python_expression_request,
            EvaluatedValue,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def no_operation(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/NoOperation",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ControllerServiceStub(betterproto.ServiceStub):
    async def retrieve_workflow_state(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RetrieveWorkflowStateResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetrieveWorkflowState",
            empty_request,
            RetrieveWorkflowStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def propagate_channel_marker(
        self,
        propagate_channel_marker_request: "PropagateChannelMarkerRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PropagateChannelMarkerResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PropagateChannelMarker",
            propagate_channel_marker_request,
            PropagateChannelMarkerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def take_global_checkpoint(
        self,
        take_global_checkpoint_request: "TakeGlobalCheckpointRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TakeGlobalCheckpointResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/TakeGlobalCheckpoint",
            take_global_checkpoint_request,
            TakeGlobalCheckpointResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def debug_command(
        self,
        debug_command_request: "DebugCommandRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/DebugCommand",
            debug_command_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def evaluate_python_expression(
        self,
        evaluate_python_expression_request: "EvaluatePythonExpressionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EvaluatePythonExpressionResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/EvaluatePythonExpression",
            evaluate_python_expression_request,
            EvaluatePythonExpressionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def console_message_triggered(
        self,
        console_message_triggered_request: "ConsoleMessageTriggeredRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ConsoleMessageTriggered",
            console_message_triggered_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def port_completed(
        self,
        port_completed_request: "PortCompletedRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PortCompleted",
            port_completed_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_workflow(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "StartWorkflowResponse":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/StartWorkflow",
            empty_request,
            StartWorkflowResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def resume_workflow(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ResumeWorkflow",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pause_workflow(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PauseWorkflow",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def worker_state_updated(
        self,
        worker_state_updated_request: "WorkerStateUpdatedRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerStateUpdated",
            worker_state_updated_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def worker_execution_completed(
        self,
        empty_request: "EmptyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerExecutionCompleted",
            empty_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def link_workers(
        self,
        link_workers_request: "LinkWorkersRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/LinkWorkers",
            link_workers_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def controller_initiate_query_statistics(
        self,
        query_statistics_request: "QueryStatisticsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ControllerInitiateQueryStatistics",
            query_statistics_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def retry_workflow(
        self,
        retry_workflow_request: "RetryWorkflowRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EmptyReturn":
        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetryWorkflow",
            retry_workflow_request,
            EmptyReturn,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RpcTesterBase(ServiceBase):

    async def send_ping(self, ping: "Ping") -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_pong(self, pong: "Pong") -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_nested(self, nested: "Nested") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_pass(self, pass_: "Pass") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_error_command(
        self, error_command: "ErrorCommand"
    ) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_recursion(self, recursion: "Recursion") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_collect(self, collect: "Collect") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_generate_number(
        self, generate_number: "GenerateNumber"
    ) -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_multi_call(self, multi_call: "MultiCall") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_chain(self, chain: "Chain") -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send_ping(
        self, stream: "grpclib.server.Stream[Ping, IntResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_ping(request)
        await stream.send_message(response)

    async def __rpc_send_pong(
        self, stream: "grpclib.server.Stream[Pong, IntResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_pong(request)
        await stream.send_message(response)

    async def __rpc_send_nested(
        self, stream: "grpclib.server.Stream[Nested, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_nested(request)
        await stream.send_message(response)

    async def __rpc_send_pass(
        self, stream: "grpclib.server.Stream[Pass, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_pass(request)
        await stream.send_message(response)

    async def __rpc_send_error_command(
        self, stream: "grpclib.server.Stream[ErrorCommand, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_error_command(request)
        await stream.send_message(response)

    async def __rpc_send_recursion(
        self, stream: "grpclib.server.Stream[Recursion, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_recursion(request)
        await stream.send_message(response)

    async def __rpc_send_collect(
        self, stream: "grpclib.server.Stream[Collect, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_collect(request)
        await stream.send_message(response)

    async def __rpc_send_generate_number(
        self, stream: "grpclib.server.Stream[GenerateNumber, IntResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_generate_number(request)
        await stream.send_message(response)

    async def __rpc_send_multi_call(
        self, stream: "grpclib.server.Stream[MultiCall, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_multi_call(request)
        await stream.send_message(response)

    async def __rpc_send_chain(
        self, stream: "grpclib.server.Stream[Chain, StringResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_chain(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPing": grpclib.const.Handler(
                self.__rpc_send_ping,
                grpclib.const.Cardinality.UNARY_UNARY,
                Ping,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPong": grpclib.const.Handler(
                self.__rpc_send_pong,
                grpclib.const.Cardinality.UNARY_UNARY,
                Pong,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendNested": grpclib.const.Handler(
                self.__rpc_send_nested,
                grpclib.const.Cardinality.UNARY_UNARY,
                Nested,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPass": grpclib.const.Handler(
                self.__rpc_send_pass,
                grpclib.const.Cardinality.UNARY_UNARY,
                Pass,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendErrorCommand": grpclib.const.Handler(
                self.__rpc_send_error_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                ErrorCommand,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendRecursion": grpclib.const.Handler(
                self.__rpc_send_recursion,
                grpclib.const.Cardinality.UNARY_UNARY,
                Recursion,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendCollect": grpclib.const.Handler(
                self.__rpc_send_collect,
                grpclib.const.Cardinality.UNARY_UNARY,
                Collect,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendGenerateNumber": grpclib.const.Handler(
                self.__rpc_send_generate_number,
                grpclib.const.Cardinality.UNARY_UNARY,
                GenerateNumber,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendMultiCall": grpclib.const.Handler(
                self.__rpc_send_multi_call,
                grpclib.const.Cardinality.UNARY_UNARY,
                MultiCall,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendChain": grpclib.const.Handler(
                self.__rpc_send_chain,
                grpclib.const.Cardinality.UNARY_UNARY,
                Chain,
                StringResponse,
            ),
        }


class WorkerServiceBase(ServiceBase):

    async def add_input_channel(
        self, add_input_channel_request: "AddInputChannelRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_partitioning(
        self, add_partitioning_request: "AddPartitioningRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def assign_port(
        self, assign_port_request: "AssignPortRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def finalize_checkpoint(
        self, finalize_checkpoint_request: "FinalizeCheckpointRequest"
    ) -> "FinalizeCheckpointResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def flush_network_buffer(
        self, empty_request: "EmptyRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def initialize_executor(
        self, initialize_executor_request: "InitializeExecutorRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def open_executor(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pause_worker(
        self, empty_request: "EmptyRequest"
    ) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def prepare_checkpoint(
        self, prepare_checkpoint_request: "PrepareCheckpointRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_statistics(
        self, empty_request: "EmptyRequest"
    ) -> "WorkerMetricsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resume_worker(
        self, empty_request: "EmptyRequest"
    ) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retrieve_state(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retry_current_tuple(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_worker(
        self, empty_request: "EmptyRequest"
    ) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def debug_command(
        self, debug_command_request: "DebugCommandRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_python_expression(
        self, evaluate_python_expression_request: "EvaluatePythonExpressionRequest"
    ) -> "EvaluatedValue":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def no_operation(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_add_input_channel(
        self, stream: "grpclib.server.Stream[AddInputChannelRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_input_channel(request)
        await stream.send_message(response)

    async def __rpc_add_partitioning(
        self, stream: "grpclib.server.Stream[AddPartitioningRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_partitioning(request)
        await stream.send_message(response)

    async def __rpc_assign_port(
        self, stream: "grpclib.server.Stream[AssignPortRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.assign_port(request)
        await stream.send_message(response)

    async def __rpc_finalize_checkpoint(
        self,
        stream: "grpclib.server.Stream[FinalizeCheckpointRequest, FinalizeCheckpointResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.finalize_checkpoint(request)
        await stream.send_message(response)

    async def __rpc_flush_network_buffer(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.flush_network_buffer(request)
        await stream.send_message(response)

    async def __rpc_initialize_executor(
        self, stream: "grpclib.server.Stream[InitializeExecutorRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.initialize_executor(request)
        await stream.send_message(response)

    async def __rpc_open_executor(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.open_executor(request)
        await stream.send_message(response)

    async def __rpc_pause_worker(
        self, stream: "grpclib.server.Stream[EmptyRequest, WorkerStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pause_worker(request)
        await stream.send_message(response)

    async def __rpc_prepare_checkpoint(
        self, stream: "grpclib.server.Stream[PrepareCheckpointRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.prepare_checkpoint(request)
        await stream.send_message(response)

    async def __rpc_query_statistics(
        self, stream: "grpclib.server.Stream[EmptyRequest, WorkerMetricsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_statistics(request)
        await stream.send_message(response)

    async def __rpc_resume_worker(
        self, stream: "grpclib.server.Stream[EmptyRequest, WorkerStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.resume_worker(request)
        await stream.send_message(response)

    async def __rpc_retrieve_state(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.retrieve_state(request)
        await stream.send_message(response)

    async def __rpc_retry_current_tuple(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.retry_current_tuple(request)
        await stream.send_message(response)

    async def __rpc_start_worker(
        self, stream: "grpclib.server.Stream[EmptyRequest, WorkerStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_worker(request)
        await stream.send_message(response)

    async def __rpc_debug_command(
        self, stream: "grpclib.server.Stream[DebugCommandRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.debug_command(request)
        await stream.send_message(response)

    async def __rpc_evaluate_python_expression(
        self,
        stream: "grpclib.server.Stream[EvaluatePythonExpressionRequest, EvaluatedValue]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.evaluate_python_expression(request)
        await stream.send_message(response)

    async def __rpc_no_operation(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.no_operation(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddInputChannel": grpclib.const.Handler(
                self.__rpc_add_input_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddInputChannelRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddPartitioning": grpclib.const.Handler(
                self.__rpc_add_partitioning,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddPartitioningRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AssignPort": grpclib.const.Handler(
                self.__rpc_assign_port,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignPortRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FinalizeCheckpoint": grpclib.const.Handler(
                self.__rpc_finalize_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                FinalizeCheckpointRequest,
                FinalizeCheckpointResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FlushNetworkBuffer": grpclib.const.Handler(
                self.__rpc_flush_network_buffer,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/InitializeExecutor": grpclib.const.Handler(
                self.__rpc_initialize_executor,
                grpclib.const.Cardinality.UNARY_UNARY,
                InitializeExecutorRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/OpenExecutor": grpclib.const.Handler(
                self.__rpc_open_executor,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PauseWorker": grpclib.const.Handler(
                self.__rpc_pause_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PrepareCheckpoint": grpclib.const.Handler(
                self.__rpc_prepare_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                PrepareCheckpointRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/QueryStatistics": grpclib.const.Handler(
                self.__rpc_query_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerMetricsResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ResumeWorker": grpclib.const.Handler(
                self.__rpc_resume_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetrieveState": grpclib.const.Handler(
                self.__rpc_retrieve_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetryCurrentTuple": grpclib.const.Handler(
                self.__rpc_retry_current_tuple,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/StartWorker": grpclib.const.Handler(
                self.__rpc_start_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/DebugCommand": grpclib.const.Handler(
                self.__rpc_debug_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                DebugCommandRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/EvaluatePythonExpression": grpclib.const.Handler(
                self.__rpc_evaluate_python_expression,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluatePythonExpressionRequest,
                EvaluatedValue,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/NoOperation": grpclib.const.Handler(
                self.__rpc_no_operation,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
        }


class ControllerServiceBase(ServiceBase):

    async def retrieve_workflow_state(
        self, empty_request: "EmptyRequest"
    ) -> "RetrieveWorkflowStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def propagate_channel_marker(
        self, propagate_channel_marker_request: "PropagateChannelMarkerRequest"
    ) -> "PropagateChannelMarkerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def take_global_checkpoint(
        self, take_global_checkpoint_request: "TakeGlobalCheckpointRequest"
    ) -> "TakeGlobalCheckpointResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def debug_command(
        self, debug_command_request: "DebugCommandRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_python_expression(
        self, evaluate_python_expression_request: "EvaluatePythonExpressionRequest"
    ) -> "EvaluatePythonExpressionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def console_message_triggered(
        self, console_message_triggered_request: "ConsoleMessageTriggeredRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def port_completed(
        self, port_completed_request: "PortCompletedRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_workflow(
        self, empty_request: "EmptyRequest"
    ) -> "StartWorkflowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resume_workflow(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pause_workflow(self, empty_request: "EmptyRequest") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def worker_state_updated(
        self, worker_state_updated_request: "WorkerStateUpdatedRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def worker_execution_completed(
        self, empty_request: "EmptyRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def link_workers(
        self, link_workers_request: "LinkWorkersRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def controller_initiate_query_statistics(
        self, query_statistics_request: "QueryStatisticsRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retry_workflow(
        self, retry_workflow_request: "RetryWorkflowRequest"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_retrieve_workflow_state(
        self,
        stream: "grpclib.server.Stream[EmptyRequest, RetrieveWorkflowStateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.retrieve_workflow_state(request)
        await stream.send_message(response)

    async def __rpc_propagate_channel_marker(
        self,
        stream: "grpclib.server.Stream[PropagateChannelMarkerRequest, PropagateChannelMarkerResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.propagate_channel_marker(request)
        await stream.send_message(response)

    async def __rpc_take_global_checkpoint(
        self,
        stream: "grpclib.server.Stream[TakeGlobalCheckpointRequest, TakeGlobalCheckpointResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.take_global_checkpoint(request)
        await stream.send_message(response)

    async def __rpc_debug_command(
        self, stream: "grpclib.server.Stream[DebugCommandRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.debug_command(request)
        await stream.send_message(response)

    async def __rpc_evaluate_python_expression(
        self,
        stream: "grpclib.server.Stream[EvaluatePythonExpressionRequest, EvaluatePythonExpressionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.evaluate_python_expression(request)
        await stream.send_message(response)

    async def __rpc_console_message_triggered(
        self,
        stream: "grpclib.server.Stream[ConsoleMessageTriggeredRequest, EmptyReturn]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.console_message_triggered(request)
        await stream.send_message(response)

    async def __rpc_port_completed(
        self, stream: "grpclib.server.Stream[PortCompletedRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.port_completed(request)
        await stream.send_message(response)

    async def __rpc_start_workflow(
        self, stream: "grpclib.server.Stream[EmptyRequest, StartWorkflowResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_workflow(request)
        await stream.send_message(response)

    async def __rpc_resume_workflow(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.resume_workflow(request)
        await stream.send_message(response)

    async def __rpc_pause_workflow(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pause_workflow(request)
        await stream.send_message(response)

    async def __rpc_worker_state_updated(
        self, stream: "grpclib.server.Stream[WorkerStateUpdatedRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.worker_state_updated(request)
        await stream.send_message(response)

    async def __rpc_worker_execution_completed(
        self, stream: "grpclib.server.Stream[EmptyRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.worker_execution_completed(request)
        await stream.send_message(response)

    async def __rpc_link_workers(
        self, stream: "grpclib.server.Stream[LinkWorkersRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.link_workers(request)
        await stream.send_message(response)

    async def __rpc_controller_initiate_query_statistics(
        self, stream: "grpclib.server.Stream[QueryStatisticsRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.controller_initiate_query_statistics(request)
        await stream.send_message(response)

    async def __rpc_retry_workflow(
        self, stream: "grpclib.server.Stream[RetryWorkflowRequest, EmptyReturn]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.retry_workflow(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetrieveWorkflowState": grpclib.const.Handler(
                self.__rpc_retrieve_workflow_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                RetrieveWorkflowStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PropagateChannelMarker": grpclib.const.Handler(
                self.__rpc_propagate_channel_marker,
                grpclib.const.Cardinality.UNARY_UNARY,
                PropagateChannelMarkerRequest,
                PropagateChannelMarkerResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/TakeGlobalCheckpoint": grpclib.const.Handler(
                self.__rpc_take_global_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                TakeGlobalCheckpointRequest,
                TakeGlobalCheckpointResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/DebugCommand": grpclib.const.Handler(
                self.__rpc_debug_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                DebugCommandRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/EvaluatePythonExpression": grpclib.const.Handler(
                self.__rpc_evaluate_python_expression,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluatePythonExpressionRequest,
                EvaluatePythonExpressionResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ConsoleMessageTriggered": grpclib.const.Handler(
                self.__rpc_console_message_triggered,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConsoleMessageTriggeredRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PortCompleted": grpclib.const.Handler(
                self.__rpc_port_completed,
                grpclib.const.Cardinality.UNARY_UNARY,
                PortCompletedRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/StartWorkflow": grpclib.const.Handler(
                self.__rpc_start_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                StartWorkflowResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ResumeWorkflow": grpclib.const.Handler(
                self.__rpc_resume_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PauseWorkflow": grpclib.const.Handler(
                self.__rpc_pause_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerStateUpdated": grpclib.const.Handler(
                self.__rpc_worker_state_updated,
                grpclib.const.Cardinality.UNARY_UNARY,
                WorkerStateUpdatedRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerExecutionCompleted": grpclib.const.Handler(
                self.__rpc_worker_execution_completed,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/LinkWorkers": grpclib.const.Handler(
                self.__rpc_link_workers,
                grpclib.const.Cardinality.UNARY_UNARY,
                LinkWorkersRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ControllerInitiateQueryStatistics": grpclib.const.Handler(
                self.__rpc_controller_initiate_query_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryStatisticsRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetryWorkflow": grpclib.const.Handler(
                self.__rpc_retry_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                RetryWorkflowRequest,
                EmptyReturn,
            ),
        }
